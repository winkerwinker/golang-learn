package map_test

import (
	"fmt"
	"testing"
)

/*

异或运算的意义

1、交换律
2、结合律 (a^b)^c == a^(b^c)
3、对于任何数x，都有 x^x=0，x^0=x
4、自反性: a^b^b=a^0=a;


*/

func TestDo6(t *testing.T) {

}

// 与操作
func andOperation() {
	fmt.Printf("%b\n", 0&0)
	fmt.Printf("%b\n", 0&1)
	fmt.Printf("%b\n", 1&0)
	fmt.Printf("%b\n", 1&1)
}

//与运算的用途：
//
//1）清零
//
// todo 如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。
//
//2）取一个数的指定位
//
// todo 比如取数 X=1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X&Y=0000 1110）即可得到X的指定位。
//
//3）判断奇偶
//
// todo 只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a & 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。

func andOperationUsage() {
	// 全部与0 就可以清零
	// 取数，找到低四位，或者找到某一位，可以使用其他全0只有那一位用0
	//
	fmt.Printf("%b\n", 0&1)
	fmt.Printf("%b\n", 1&0)
	fmt.Printf("%b\n", 1&1)
	// 判断是否是奇偶

}

// 或运算的使用
// 注意：负数按补码形式参加按位或运算。
//  todo 常用来对一个数据的某些位设置为1，与运算可以判断原有的是不是1 ，或运算可以将直接置为1
// 比如将数 X=1010 1110 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，
// 其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X|Y=1010 1111）即可得到。
func orOperationUsage() {

}

// 异或运算
//异或运算的用途：
// todo 与1 反转，与0 不变
//
//1）todo 翻转指定位
//
//比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。
//
//2）与0相异或值不变
//
//例如：1010 1110 ^ 0000 0000 = 1010 1110
//
//3）交换两个数
func orAndOperationUsage() {

}

func Swap(a int, b int) {
	// 只有这个商品
	if a != b {
		a ^= b
		b ^= a
		a ^= b
	}
}

// 取反运算~1=0
//&=        例：a&=b    相当于     a=a&b
//|=        例：a|=b    相当于     a=a|b ，todo 赋予给A
//>>=      例：a>>=b   相当于     a=a>>b
//<<=      例：a<<=b     相当于      a=a<<b
//^=        例：a^=b    相当于   a=a^b

// others 运算规则：和前面讲的复合赋值运算符的运算规则相似。
//
//不同长度的数据进行位运算：如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。
//
//以"与运算"为例说明如下：我们知道在C语言中long型占4个字节，int型占2个字节，如果一个long型数据与一个int型数据进行"与运算"，右端对齐后，左边不足的位依下面三种情况补足，
////
//1）如果整型数据为正数，左边补16个0。
//2）如果整型数据为负数，左边补16个1。
//3）如果整形数据为无符号数，左边也补16个0。
//如：long a=123；int b=1；计算a& b。
//如：long a=123；int b=-1；计算a& b。
//
//如：long a=123；unsigned intb=1；计算a & b。
